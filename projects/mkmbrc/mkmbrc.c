/* 
 * mkmbrc -- create mbr.c from mbr binary
 * 
 * Copyright (C) 2010  Anonymous
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to 
 * the Free Software Foundation, Inc.
 * 51 Franklin Street, Fifth Floor
 * Boston, MA  02110-1301, USA
 * 
 */

#ifdef _WIN32
#include <io.h>
#include <fcntl.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define LDRSIZE	512

void writehead(FILE *out) {
	fprintf(out, "/* This file has been automatically generated by mkmbrc.exe */\n\n");
	fprintf(out, "#include <string.h>\n\n");
}

void writetable(FILE *out, char *loader, int size, char *offset) {
	int i;

	fprintf(out, "char imgloader[] = {");
	for(i = 0; i < size; i++) {
		if(!(i % 16))
			fprintf(out, "\n\t");

		fprintf(out, "0x%02x", loader[i] & 255);

		if(i < (size - 1)) 
			fprintf(out, ", ");
		else
			fprintf(out, "\n");		
	}

	fprintf(out, "};\n\n");
	fprintf(out, "char *imgaddr = &imgloader[%s];\n\n", offset);
}

void writetail(FILE *out) {
	fprintf(out, "char *getImgRec(char *addr) {\n");
	fprintf(out, "\tmemcpy(imgaddr, addr, 8);\n");
	fprintf(out, "\treturn imgloader;\n");
	fprintf(out, "}\n");
}

int main(int argc, char **argv) {
	FILE *input, *output;
	int size, offset;
	char *loader, *addcode;
	
	if(argc < 4) {
		fprintf(stderr, "USAGE: mkmbrc.exe <BINARY> <OUTPUT> <ADDRESSOFFSET> [ADDITIONAL CODE]\n");
		return -1;
	}

	printf("Opening %s...\n", argv[1]);
	if((input = fopen(argv[1], "rb")) == NULL) {
		fprintf(stderr, "ERROR: Could not open '%s' for reading.\n", argv[1]);
		return -1;
	}

	printf("Opening %s...\n", argv[2]);
	if((output = fopen(argv[2], "w")) == NULL) {
		fprintf(stderr, "ERROR: Could not open '%s' for writing.\n", argv[2]);
		fclose(input);
		return -1;
	}

	offset = atoi(argv[3]);

	if((loader = (char*)malloc(LDRSIZE)) == NULL) {
		fprintf(stderr, "ERROR: Could not allocate %d bytes of memory.\n", LDRSIZE);
		fclose(input);
		fclose(output);
		return -1;
	}

	fseek(input, 0, SEEK_END);
	size = ftell(input);
	if(size > LDRSIZE) {
		fprintf(stderr, "WARNING: Input file is bigger than %d bytes. (%d bytes)\n", LDRSIZE, size);
	} else if(size < LDRSIZE) {
		fprintf(stderr, "WARNING: Input file is smaller than %d bytes. (%d bytes)\n", LDRSIZE, size);
	}
	printf("Reading input file...\n");
	fflush(stdout);

	fseek(input, 0, SEEK_SET);
	fread(loader, LDRSIZE, 1, input);

	printf("Writing head...\n");
	writehead(output);
	printf("Writing table (Offset = %s)...\n", argv[3]);
	writetable(output, loader, LDRSIZE, argv[3]);
	printf("Writing tail...\n");
	writetail(output);
	printf("Done.\n");
	fclose(output);

	if(size > LDRSIZE) {
		if(argc < 5) {
			if((addcode = (char*)malloc(512)) == NULL)
				return -1;
			strcpy(addcode, "a.out");
		} else
			addcode = argv[4];

		printf("Writing additional code to %s...\n", addcode);

		output = fopen(addcode, "wb");

		do {
			size = fread(loader, LDRSIZE, 1, input);
			fwrite(loader, size * LDRSIZE, 1, output);
		} while (!feof(input));

		printf("Done.\n");
	}
	
	fclose(input);
	free(loader);
	return 0;
}